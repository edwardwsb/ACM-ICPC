// https://blog.csdn.net/ACMer_ZP/article/details/78570926
// 网格图可转化为二分图，每个点对应一条边，点的坐标对应边的两个端点
// 建图的时候，只需要连接 x 到 y 的边即可，不需要连接 y 到 x 的边，匈牙利算法遍历的时候也只是遍历 x 部的点
// 除非题目给出的点无法确定属于 x 部还是 y 部，那就都存下来，做完最大匹配后，将最大匹配数除以 2 即可。

// 【最大匹配】
// 匹配：在图论中，一个「匹配」 (matching) 是一个边的集合，其中任意两条边都没有公共顶点。
// 最大匹配：一个图所有匹配中，所含匹配边数最多的匹配，称为这个图的最大匹配。
// 算法： 匈牙利算法求二分图的最大匹配
// https://blog.csdn.net/c20180630/article/details/70175814

vi e[N];
int match[N];
bool vis[N];    // 仅用来存 y 部点的标记情况，所以 x 部的点与 y 部的点标号重复也没有关系
struct Hungary {
    void init() { memset(match, -1, sizeof(match)); }
    bool dfs(int u) {
        rep(i, 0, sz(e[u])) {
            int v = e[u][i];
            if (!vis[v]) {
                vis[v] = 1;
                if (match[v] == -1 || dfs(match[v])) {
                    match[v] = u;
                    return true;
                }
            }
        }
        return false;
    }
    int hungary() {   // 返回最大匹配数
        int res = 0;
        rep(i, 0, n) {  // x 部的点标号的范围
            memset(vis, 0, sizeof(vis));
            res += dfs(i);
        }
        return res;
    }
};

------------------------------------------------------------------------------------------------

// 【最佳匹配】
// 完备匹配：如果一个匹配中，图中的每个顶点都和图中某条边相关联，则称此匹配为完全匹配，也称作完备匹配。 
// 最佳匹配：带权二分图的权值最大的完备匹配称为最佳匹配。
// 注意：二分图的最佳匹配不一定是二分图的最大权匹配。 
// 转化：可以添加一些权值为 0 的边，使得最佳匹配和最大权匹配统一起来。
// https://blog.csdn.net/c20180630/article/details/71080521
// https://blog.csdn.net/u014097230/article/details/51554905

int n;
int match[N], wx[N], wy[N], g[N][N], slack[N];
bool visx[N], visy[N];
struct KM {
    void init() {
        memset(match, -1, sizeof(match));
        memset(wy, 0, sizeof(wy));
        rep(i, 0, n) {
            wx[i] = g[i][0];
            rep(j, 1, n) wx[i] = max(wx[i], g[i][j]);
        }
    }
    bool dfs(int x) {
        visx[x] = 1;
        rep(y, 0, n) {
            if (visy[y]) continue;
            int gap = wx[x] + wy[y] - g[x][y];
            if (gap == 0) {
                visy[y] = 1;
                if (match[y] == -1 || dfs( match[y] )) {
                    match[y] = x;
                    return true;
                }
            } else {
                slack[y] = min(slack[y], gap);
            }
        }
        return false;
    }
    int km() {
        rep(i, 0, n) {
            memset(slack, 0x3f, sizeof(slack));
            while (1) {
                memset(visx, 0, sizeof(visx));
                memset(visy, 0, sizeof(visy));
                if (dfs(i)) break;
                int d = INF;
                rep(j, 0, n) if (!visy[j]) d = min(d, slack[j]);
                rep(j, 0, n) {
                    if (visx[j]) wx[j] -= d;
                    if (visy[j]) wy[j] += d;
                    else slack[j] -= d;
                }
            }
        }
        int res = 0;
        rep(i, 0, n) res += g[match[i]][i];
        return res;
    }
};

------------------------------------------------------------------------------------------------

// 【最小点覆盖】
// 点覆盖：对于图 G = (V, E) 中的一个点覆盖是一个集合 S 属于 V 使得每一条边至少有一个端点在 S 中。
// 最小点覆盖：点的个数最少的 S 集合。 
// 结论： 二分图的最小点覆盖数 = 该二分图的最大匹配数
// 构造方案：
// 找到所有未被匹配的点，则与它们相连的所有顶点都属于 S ，将这些顶点打上标记，
// 然后在最大匹配中找两边都没有被标记的边，任选一个端点作为最小点覆盖中的点。

------------------------------------------------------------------------------------------------

// 【最小边覆盖】
// 边覆盖：边覆盖是图的一个边子集，使该图上每一节点都与这个边子集中的一条边关联，含孤立点的图没有边覆盖。
// 最小边覆盖：边数最少的覆盖
// 结论：二分图的最小边覆盖数 = 图中的顶点数 - ( 最小点覆盖数 ) 该二分图的最大匹配数

------------------------------------------------------------------------------------------------

// 【最小路径覆盖】

// DAG (有向无环图)
// https://www.cnblogs.com/justPassBy/p/5369930.html
  
// 定义：在一个有向图中，找出最少的路径，使得这些路径经过了所有的点。特别的，每个点自己也可以称为是路径覆盖，只不过路径的长度是 0
// 最小路径覆盖分为【最小不相交路径覆盖】和【最小可相交路径覆盖】。

// 【最小不相交路径覆盖】
// 最小不相交路径覆盖：每一条路径经过的顶点各不相同。
// 算法：
// 把原图的每个点 V 拆成 Vx 和 Vy 两个点，如果有一条有向边 A->B ，那么就加边 Ax−>By 。
// 这样就得到了一个二分图。那么最小路径覆盖 = 原图的结点数 - 新图的最大匹配数。
// 代码：
// 直接建有向图的邻接表，跑匈牙利算法即可。

// 【最小可相交路径覆盖】
// 最小可相交路径覆盖：每一条路径经过的顶点可以相同。
// 算法：
// 先用 floyd 求出原图的传递闭包，即如果a到b有路径，那么就加边a->b。然后就转化成了最小不相交路径覆盖问题。
// 代码：
// 用 floyd 更新邻接矩阵，然后跑邻接矩阵版的匈牙利算法。

------------------------------------------------------------------------------------------------

// 【最大独立集】
// 独立集：给一无向图，找出一个点集，使得任意两点之间都没有连边，这个点集就是独立集。
// 最大独立集：点最多的独立集，就是最大独立集。
// 结论：二分图的最大点独立数 = 图中的顶点数 - ( 最小点覆盖数 ) 该二分图的最大匹配数
// 构造方案：最大独立集 S 与 最小覆盖集 T 互补
