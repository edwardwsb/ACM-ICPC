// https://blog.csdn.net/ACMer_ZP/article/details/78570926

// 【最大匹配】
// 匹配：在图论中，一个「匹配」（matching）是一个边的集合，其中任意两条边都没有公共顶点。
// 最大匹配：一个图所有匹配中，所含匹配边数最多的匹配，称为这个图的最大匹配。
// 算法： 匈牙利算法求二分图的最大匹配
// 如果一个匹配中，图中的每个顶点都和图中某条边相关联，则称此匹配为完全匹配，也称作完备匹配。
// https://blog.csdn.net/c20180630/article/details/70175814

vi e[N];
int link[N];
bool vis[N];
struct Hungary {
    void init() { memset(link, 0, sizeof(link)); }
    bool dfs(int u) {
        rep(i, 0, sz(e[u])) {
            int v = e[u][i];
            if (!vis[v]) {
                vis[v] = 1;
                if (!link[v] || dfs(link[v])) {
                    link[v] = u;
                    return true;
                }
            }
        }
        return false;
    }
    int hungary() {   // 返回最大匹配数
        int res = 0;
        rep(i, 1, n+1) {
            memset(vis, 0, sizeof(vis));
            res += dfs(i);
        }
        return res;
    }
};

------------------------------------------------------------------------------------------------

// 【最小点覆盖】
// 点覆盖：对于图 G=(V,E) 中的一个点覆盖是一个集合 S⊆V 使得每一条边至少有一个端点在 S 中。
// 最小点覆盖：点的个数最少的 S 集合。 
// 结论： 二分图的最小点覆盖数 = 该二分图的最大匹配数
// 构造方案：
// 找到所有未被匹配的点，则与它们相连的所有顶点都属于 S ，将这些顶点打上标记，
// 然后在最大匹配中找两边都没有被标记的边，任选一个端点作为最小点覆盖中的点。

------------------------------------------------------------------------------------------------

// 【最小边覆盖】
// 边覆盖：边覆盖是图的一个边子集，使该图上每一节点都与这个边子集中的一条边关联，含孤立点的图没有边覆盖。
// 最小边覆盖：边数最少的覆盖
// 结论：二分图的最小边覆盖数 = 图中的顶点数 - (最小点覆盖数)该二分图的最大匹配数

------------------------------------------------------------------------------------------------

// 【最小路径覆盖】

// DAG (有向无环图)
// https://www.cnblogs.com/justPassBy/p/5369930.html
  
// 定义：在一个有向图中，找出最少的路径，使得这些路径经过了所有的点。特别的，每个点自己也可以称为是路径覆盖，只不过路径的长度是0。
// 最小路径覆盖分为【最小不相交路径覆盖】和【最小可相交路径覆盖】。

// 【最小不相交路径覆盖】
// 最小不相交路径覆盖：每一条路径经过的顶点各不相同。
// 算法：
// 把原图的每个点 V 拆成 Vx 和 Vy 两个点，如果有一条有向边 A->B ，那么就加边 Ax−>By 。
// 这样就得到了一个二分图。那么最小路径覆盖 = 原图的结点数 - 新图的最大匹配数。
// 代码：
// 直接建有向图的邻接表，跑匈牙利算法即可。

// 【最小可相交路径覆盖】
// 最小可相交路径覆盖：每一条路径经过的顶点可以相同。
// 算法：
// 先用 floyd 求出原图的传递闭包，即如果a到b有路径，那么就加边a->b。然后就转化成了最小不相交路径覆盖问题。
// 代码：
// 用 floyd 更新邻接矩阵，然后跑邻接矩阵版的匈牙利算法。

------------------------------------------------------------------------------------------------

// 【最大独立集】
// 独立集：给一无向图，找出一个点集，使得任意两点之间都没有连边，这个点集就是独立集。
// 最大独立集：点最多的独立集，就是最大独立集。
// 结论：二分图的最大点独立数 = 图中的顶点数 - (最小点覆盖数)该二分图的最大匹配数
// 构造方案：最大独立集 S 与 最小覆盖集 T 互补
