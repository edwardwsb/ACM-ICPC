================================================== Problem Set ==================================================

// cf 118D
// 题意： n1 个步兵， n2 个骑兵，排成一列，求连续的步兵不超过 k1 个，连续的骑兵不超过 k2 个的方案数
// 题解： dp[i][j][k] 表示用了 i 个步兵， j 个骑兵，最后一个是第 k 种兵种
int Solve() {
    dp[0][0][0] = dp[0][0][1] = 1;
    rep(i, 0, n1+1) rep(j, 0, n2+1) rep(k, 0, 2) {
        if (k) rep(ii, 1, min(i, k1)+1) dp[i][j][k] += dp[i-ii][j][k^1];  // 在末尾连续放 ii 个步兵
        else rep(jj, 1, min(j, k2)+1) dp[i][j][k] += dp[i][j-jj][k^1];    // 在末尾连续放 jj 个骑兵
    }
    return printf("%d\n", dp[n1][n2][0] + dp[n1][n2][1]);
}
