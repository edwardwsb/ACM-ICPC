# 斜率优化

## 例题 1 : POJ1180

**题意**

N 个任务，按顺序执行。

执行第 i 个任务所需时间 Ti 。

可以把任务分成若干批，每批连续的若干个任务。

每批任务开始前需 S 的启动时间，故执行一批任务所需时间为 S 加上每个任务所需时间之和。

同一批任务同一时刻完成，即该批任务全部执行完毕。

每个任务的费用为完成时刻乘以费用系数 Ci

请规划分组方案，使得总费用最小。

**题解**

$$
\large F[i]=\mathop{min}\limits_{0\le j<i}\{F[j]+sumT[i]*(sumC[i]-sumC[j])+S*(sumC[N]-sumC[j])\}
$$

F[i] 表示把前 i 个任务分成若干批执行的最小费用。

第 j + 1 到 i 个任务在同一批内完成。

sumC 和 sumT 表示 C 和 T 的前缀和。

sumT 是忽略机器的启动时间时，这批任务的完成时刻。

启动时间 S 会对第 j + 1 个之后的所有任务产生影响。—— “费用提前计算”

**斜率优化**

状态转移方程变形：$\large y = kx+b$

（仅与 j 有关的项）=（i ，j 的乘积项）+（常数、仅与 i 有关的项）

$$
\large F[j]=(S+sumT[i])*sumC[j]+F[i]-sumT[i]*sumC[i]-S*sumC[N]
$$

点坐标：( sumC[j] , F[j] )

斜率：S + sumT[i]

截距：F[i] - sumT[i] \* sumC[i] - S \* sumC[N]

斜率固定，求经过哪个点，使得截距最小。

**特征**

- 横坐标单调递增 —— 点出现在凸壳最右端

- 斜率单调递增 —— 维护线段斜率大于直线斜率的线段

所以，维护凸壳上 “连接相邻两点的线段的斜率” 大于 S + sumT[i] 的部分，则凸壳最左端顶点为最优决策。

**维护**

单调队列 Q

1. 检查队首两个元素，若斜率 $(F[Q[l+1]]-F[Q[l]])/(sumC[Q[l+1]]-sumC[Q[l]]) \le S + sumT[i]$ ，则队首出队，继续检查队首元素。
2. 取队首为最优决策，计算出 $F[i]$ 。
3. 新决策 i 插入队尾，若队尾三个元素不满足下凸性，则中间元素出队，继续检查队尾元素。

**代码**

```c++
/* <<head>> */
const int N = (int)1e6+7;

// -------------------------------------- 变量 -------------------------------------- //

int n, s, t[N], c[N];
ll sumT[N], sumC[N];
ll dp[N];

// -------------------------------------- 函数 -------------------------------------- //

void Init() {
    rep(i, 1, n+1) scanf("%d%d", t+i, c+i);
    rep(i, 1, n+1) {
        sumT[i] = sumT[i-1] + t[i];
        sumC[i] = sumC[i-1] + c[i];
    }
}

struct P {
    ll x, y;
    P () {} P (ll x, ll y) : x(x), y(y) {}
    P operator - (const P &rhs) const { return P(x - rhs.x, y - rhs.y); }
    
    // 叉积可能爆 long long ，返回叉积是否大于 0
    bool operator ^ (const P &rhs) const { return (db)x * rhs.y > (db)y * rhs.x; }
};
#define X(i) (sumC[i])      // 点的横坐标
#define Y(i) (dp[i])        // 点的纵坐标
#define K(i) (s + sumT[i])  // 直线斜率

int Solve() {
    dp[0] = 0;        // 0 个任务费用为 0
    deque <P> Q; Q.pb(P(X(0), Y(0)));    // 设置初值
    rep(i, 1, n+1) {
        // 队首斜率 小于 直线斜率
        while (sz(Q) > 1 && (Q[1].y - Q[0].y) < (Q[1].x - Q[0].x) * K(i)) Q.pop_front();
        
        // dp[i] 通过 dp[j] 的转移式
        dp[i] = Q[0].y - K(i) * Q[0].x + sumT[i] * sumC[i] + s * sumC[n];
        
        // 第 i 个结点待入队
        P a(X(i), Y(i));
        
        // 队尾元素是否下凸
        while (sz(Q) > 1 && !((Q[sz(Q)-2] - a) ^ (Q.back() - a))) Q.pop_back();
        
        // 第 i 个结点入队
        Q.pb(a);
    }
    return printf("%lld\n", dp[n]);
}

// -------------------------------------- main -------------------------------------- //

int main ()
{
    while (~scanf("%d%d", &n, &s)) {
        Init();
        Solve();
    }
    return 0;
}
```

---

## 例题 2 : BZOJ2726

**题意**

同 “ 例题 1 ” ，但 T 可能为负数。

**题解**

$$
\large F[j]=(S+sumT[i])*sumC[j]+F[i]-sumT[i]*sumC[i]-S*sumC[N]
$$

**特征**

- 横坐标单调递增 —— 点出现在凸壳最右端

- 直线斜率不具有单调性 —— 维护整个凸壳，二分查找答案

**维护**

单调队列 Q

1. 二分查找最优决策，左侧线段斜率比直线斜率小，右侧线段斜率比直线斜率大。
3. 新决策 i 插入队尾，若队尾三个元素不满足下凸性，则中间元素出队，继续检查队尾元素。

**代码**

```c++
/* <<head>> */
const int N = (int)1e6+7;

// -------------------------------------- 变量 -------------------------------------- //

int n, s, t[N], c[N];
ll sumT[N], sumC[N];
ll dp[N];

// -------------------------------------- 函数 -------------------------------------- //

void Init() {
    rep(i, 1, n+1) scanf("%d%d", t+i, c+i);
    rep(i, 1, n+1) {
        sumT[i] = sumT[i-1] + t[i];
        sumC[i] = sumC[i-1] + c[i];
    }
}

struct P {
    ll x, y;
    P () {} P (ll x, ll y) : x(x), y(y) {}
    P operator - (const P &rhs) const { return P(x - rhs.x, y - rhs.y); }
    
    // 叉积可能爆 long long ，返回叉积是否大于 0
    bool operator ^ (const P &rhs) const { return (db)x * rhs.y > (db)y * rhs.x; }
};
#define X(i) (sumC[i])      // 点的横坐标
#define Y(i) (dp[i])        // 点的纵坐标
#define K(i) (s + sumT[i])  // 直线斜率

int Solve() {
    dp[0] = 0;        // 0 个任务费用为 0
    deque <P> Q; Q.pb(P(X(0), Y(0)));    // 设置初值
    rep(i, 1, n+1) {
        // 二分查找最优决策，左侧线段斜率比直线斜率小，右侧线段斜率比直线斜率大
        int L = 0, R = sz(Q) - 1;
        while (L < R) {
            int M = (L + R) >> 1;
            if (Q[M+1].y - Q[M].y <= K(i) * (Q[M+1].x - Q[M].x)) L = M + 1;
            else R = M;
        }
        
        // 点 Q[L] 为最优决策点，转移获得 dp[i]
        dp[i] = Q[L].y - K(i) * Q[L].x + sumT[i] * sumC[i] + s * sumC[n];
        
        // 第 i 个结点待入队
        P a(X(i), Y(i));
        
        // 队尾元素是否下凸
        while (sz(Q) > 1 && !((Q[sz(Q)-2] - a) ^ (Q.back() - a))) Q.pop_back();
        
        // 第 i 个结点入队
        Q.pb(a);
    }
    return printf("%lld\n", dp[n]);
}

// -------------------------------------- main -------------------------------------- //

int main ()
{
    while (~scanf("%d%d", &n, &s)) {
        Init();
        Solve();
    }
    return 0;
}
```

