# 括号匹配

## 例题 1 : CF466D

**题意**

给定一个长度为 n 的序列，每次操作可以将一个区间的值全部加一，但是不能有某个端点同时作为两个区间的左端点或右端点（可以既做左端点，又做右端点），问有多少种方案可以使得所有数字变成 h 。

**题解**

dp[i]\[j] 表示前 i 个数里，有 j 个待匹配的左括号。

对于第 i 个数，有五种情况：

1. 不做端点
2. 自成一个区间，既做左端点，又做右端点
3. 做后面一个区间的左端点
4. 做前面一个区间的右端点
5. 既做前面一个区间的右端点，又做后面一个区间的左端点

**代码**

```c++
/* <<head>> */
const int MOD = (int)1e9+7;
const int N = (int)2e3+7;

// ------- 变量 ------- //

int n, h;
int a[N], dp[N][N];

// ------- 函数 ------- //

void Init() {
	memset(dp, 0, sizeof(dp));
    rep(i, 1, n+1) scanf("%d", a+i);
}

inline int add(ll a, int b) { if ((a += b) >= MOD) a -= MOD; return a; }
inline int mul(ll a, int b) { if ((a *= b) >= MOD) a %= MOD; return a; }

int Solve() {
	dp[0][0] = 1;  // 前 0 个数，有 0 个待匹配的左括号，方案数为 1
    
    // 向前 dp ，考虑 dp[i][j] 从哪些地方转移而来
	rep(i, 1, n+1) rep(j, 0, i+1) {
        // 因为当前要计算的是 dp[i][j] ，所以要根据不同情况选择前一个状态 : j, j-1, j+1
        
        // 情况 1 : a[i] 要被 j 个区间覆盖，所以需要 a[i] + j == h
		/* -- */ if (a[i] + j == h) dp[i][j] = add(dp[i][j], dp[i-1][j]);
		
        // 情况 2 : a[i] 被前 j 个区间覆盖，又被自己的区间覆盖
        /* [] */ if (a[i] + j + 1 == h) dp[i][j] = add(dp[i][j], dp[i-1][j]);
		
        // 情况 3 : a[i] 被前 j-1 个区间覆盖，又被自己新开的区间覆盖
        /* [  */ if (j && a[i] + j == h) dp[i][j] = add(dp[i][j], dp[i-1][j-1]);
		
        // 情况 4 : a[i] 被前 j+1 个区间覆盖
        /*  ] */ if (a[i] + j + 1 == h) dp[i][j] = add(dp[i][j], mul(j+1, dp[i-1][j+1]));
		
        // 情况 5 : a[i] 被前 j 个区间覆盖，又被自己新开的区间覆盖
        /* ][ */ if (a[i] + j + 1 == h) dp[i][j] = add(dp[i][j], mul(j, dp[i-1][j]));
	}
	return printf("%d\n", dp[n][0]);
}

// ------- main ------- //

int main ()
{
    while (~scanf("%d%d", &n, &h)) {
        Init();
        Solve();
    }
    return 0;
}
```

---

## 例题 2 : CF626F

**题意**

给定 n 个数，分为若干组，求每组极差之和不超过 k 的方案数。

**题解**

dp[i]\[j]\[k] 表示前 i 个数里，有 j 个待匹配的左括号，目前极差之和为 k 。

对于第 i 个数，有四种情况：

1. 在前面一个集合中，不是第一个元素，也不是最后一个元素
2. 自成一个集合，既是第一个元素，又是最后一个元素
3. 做后面一个集合的第一个元素
4. 做前面一个集合的最后一个元素

**代码**

```c++
/* <<head>> */
const int MOD = (int)1e9+7;
const int N = (int)200+7;

// ------- 变量 ------- //

int n, kk;
int a[N], dp[N][N][1007];

// ------- 函数 ------- //

inline int add(ll a, int b) { if ((a += b) >= MOD) a -= MOD; return a; }
inline int mul(ll a, int b) { if ((a *= b) >= MOD) a %= MOD; return a; }

void Init() {
	memset(dp, 0, sizeof(dp));

    rep(i, 1, n+1) scanf("%d", a+i);
    sort(a + 1, a + n + 1);
}

int Solve() {
	dp[0][0][0] = 1;  // 前 0 个数，有 0 个待匹配的左括号，极差之和为 0 的方案数为 1
    
    // 向后 dp ，确定 dp[i][j][k] ，向后能转移给哪些地方
	rep(i, 0, n) rep(j, 0, i+1) rep(k, 0, kk+1) { // i 从 0 到 n-1
        
        // 在前 i 个数里，有 j 个待匹配的左括号，所以 a[i+1] 与 a[i] 一定贡献 j 个差值
		int cha = a[i+1] - a[i], tk = k + j * cha;
		if (tk > kk) continue;
        
        // 凡是涉及第 i+1 个从前面 j 个集合中选一个的，方案数都需要乘 j （第 1 种和第 4 种）
		/* -- */ dp[i+1][j][tk] = add(dp[i+1][j][tk], mul(j, dp[i][j][k]));
		/* [] */ dp[i+1][j][tk] = add(dp[i+1][j][tk], dp[i][j][k]);
		/* [  */ dp[i+1][j+1][tk] = add(dp[i+1][j+1][tk], dp[i][j][k]);
		/*  ] */ if (j) dp[i+1][j-1][tk] = add(dp[i+1][j-1][tk], mul(j, dp[i][j][k]));
	}
	int ans = 0;
	rep(i, 0, kk+1) ans = add(ans, dp[n][0][i]);
	return printf("%d\n", ans);
}

// ------- main ------- //

int main ()
{
    while (~scanf("%d%d", &n, &kk)) {
        Init();
        Solve();
    }
    return 0;
}
```

